import {
  __commonJS
} from "./chunk-Y2F7D3TJ.js";

// ../../../../../node_modules/inline-worker/index.js
var require_inline_worker = __commonJS({
  "../../../../../node_modules/inline-worker/index.js"(exports, module) {
    var WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);
    function InlineWorker(func, self) {
      var _this = this;
      var functionBody;
      self = self || {};
      if (WORKER_ENABLED) {
        functionBody = func.toString().trim().match(
          /^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/
        )[1];
        return new global.Worker(global.URL.createObjectURL(
          new global.Blob([functionBody], { type: "text/javascript" })
        ));
      }
      function postMessage(data) {
        setTimeout(function() {
          _this.onmessage({ data });
        }, 0);
      }
      this.self = self;
      this.self.postMessage = postMessage;
      setTimeout(func.bind(self, self), 0);
    }
    InlineWorker.prototype.postMessage = function postMessage(data) {
      var _this = this;
      setTimeout(function() {
        _this.self.onmessage({ data });
      }, 0);
    };
    module.exports = InlineWorker;
  }
});

// ../../../../../node_modules/recorder-js/lib/microphone.js
var require_microphone = __commonJS({
  "../../../../../node_modules/recorder-js/lib/microphone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _inlineWorker = require_inline_worker();
    var _inlineWorker2 = _interopRequireDefault(_inlineWorker);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var defaultConfig = {
      bufferLen: 4096,
      numChannels: 2,
      mimeType: "audio/wav"
    };
    var Microphone = function() {
      function Microphone2(source, config) {
        var _this = this;
        _classCallCheck(this, Microphone2);
        this.config = Object.assign({}, defaultConfig, config);
        this.recording = false;
        this.callbacks = {
          getBuffer: [],
          exportWAV: []
        };
        this.context = source.context;
        this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(this.context, this.config.bufferLen, this.config.numChannels, this.config.numChannels);
        this.node.onaudioprocess = function(e) {
          if (!_this.recording)
            return;
          var buffer = [];
          for (var channel = 0; channel < _this.config.numChannels; channel++) {
            buffer.push(e.inputBuffer.getChannelData(channel));
          }
          _this.worker.postMessage({
            command: "record",
            buffer
          });
        };
        source.connect(this.node);
        this.node.connect(this.context.destination);
        var self = {};
        this.worker = new _inlineWorker2.default(function() {
          var recLength = 0, recBuffers = [], sampleRate = void 0, numChannels = void 0;
          this.onmessage = function(e) {
            switch (e.data.command) {
              case "init":
                init(e.data.config);
                break;
              case "record":
                record(e.data.buffer);
                break;
              case "exportWAV":
                exportWAV(e.data.type);
                break;
              case "getBuffer":
                getBuffer();
                break;
              case "clear":
                clear();
                break;
            }
          };
          function init(config2) {
            sampleRate = config2.sampleRate;
            numChannels = config2.numChannels;
            initBuffers();
          }
          function record(inputBuffer) {
            for (var channel = 0; channel < numChannels; channel++) {
              recBuffers[channel].push(inputBuffer[channel]);
            }
            recLength += inputBuffer[0].length;
          }
          function exportWAV(type) {
            var buffers = [];
            for (var channel = 0; channel < numChannels; channel++) {
              buffers.push(mergeBuffers(recBuffers[channel], recLength));
            }
            var interleaved = void 0;
            if (numChannels === 2) {
              interleaved = interleave(buffers[0], buffers[1]);
            } else {
              interleaved = buffers[0];
            }
            var dataview = encodeWAV(interleaved);
            var audioBlob = new Blob([dataview], { type });
            this.postMessage({ command: "exportWAV", data: audioBlob });
          }
          function getBuffer() {
            var buffers = [];
            for (var channel = 0; channel < numChannels; channel++) {
              buffers.push(mergeBuffers(recBuffers[channel], recLength));
            }
            this.postMessage({ command: "getBuffer", data: buffers });
          }
          function clear() {
            recLength = 0;
            recBuffers = [];
            initBuffers();
          }
          function initBuffers() {
            for (var channel = 0; channel < numChannels; channel++) {
              recBuffers[channel] = [];
            }
          }
          function mergeBuffers(recBuffers2, recLength2) {
            var result = new Float32Array(recLength2);
            var offset = 0;
            for (var i = 0; i < recBuffers2.length; i++) {
              result.set(recBuffers2[i], offset);
              offset += recBuffers2[i].length;
            }
            return result;
          }
          function interleave(inputL, inputR) {
            var length = inputL.length + inputR.length;
            var result = new Float32Array(length);
            var index = 0, inputIndex = 0;
            while (index < length) {
              result[index++] = inputL[inputIndex];
              result[index++] = inputR[inputIndex];
              inputIndex++;
            }
            return result;
          }
          function floatTo16BitPCM(output, offset, input) {
            for (var i = 0; i < input.length; i++, offset += 2) {
              var s = Math.max(-1, Math.min(1, input[i]));
              output.setInt16(offset, s < 0 ? s * 32768 : s * 32767, true);
            }
          }
          function writeString(view, offset, string) {
            for (var i = 0; i < string.length; i += 1) {
              view.setUint8(offset + i, string.charCodeAt(i));
            }
          }
          function encodeWAV(samples) {
            var buffer = new ArrayBuffer(44 + samples.length * 2);
            var view = new DataView(buffer);
            writeString(view, 0, "RIFF");
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, "WAVE");
            writeString(view, 12, "fmt ");
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 4, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, "data");
            view.setUint32(40, samples.length * 2, true);
            floatTo16BitPCM(view, 44, samples);
            return view;
          }
        }, self);
        this.worker.postMessage({
          command: "init",
          config: {
            sampleRate: this.context.sampleRate,
            numChannels: this.config.numChannels
          }
        });
        this.worker.onmessage = function(e) {
          var cb = _this.callbacks[e.data.command].pop();
          if (typeof cb === "function") {
            cb(e.data.data);
          }
        };
      }
      _createClass(Microphone2, [{
        key: "record",
        value: function record() {
          this.recording = true;
        }
      }, {
        key: "stop",
        value: function stop() {
          this.recording = false;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.worker.postMessage({ command: "clear" });
        }
      }, {
        key: "getBuffer",
        value: function getBuffer(cb) {
          cb = cb || this.config.callback;
          if (!cb)
            throw new Error("Callback not set");
          this.callbacks.getBuffer.push(cb);
          this.worker.postMessage({ command: "getBuffer" });
        }
      }, {
        key: "exportWAV",
        value: function exportWAV(cb, mimeType) {
          mimeType = mimeType || this.config.mimeType;
          cb = cb || this.config.callback;
          if (!cb)
            throw new Error("Callback not set");
          this.callbacks.exportWAV.push(cb);
          this.worker.postMessage({
            command: "exportWAV",
            type: mimeType
          });
        }
      }]);
      return Microphone2;
    }();
    Microphone.forceDownload = function forceDownload(blob, filename) {
      var a = document.createElement("a");
      a.style = "display: none";
      document.body.appendChild(a);
      var url = window.URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    };
    exports.default = Microphone;
  }
});

// ../../../../../node_modules/recorder-js/lib/index.js
var require_lib = __commonJS({
  "../../../../../node_modules/recorder-js/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _microphone = require_microphone();
    var _microphone2 = _interopRequireDefault(_microphone);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var defaultConfig = {
      nFrequencyBars: 255,
      onAnalysed: null
    };
    var Recorder = function() {
      function Recorder2(audioContext) {
        var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Recorder2);
        this.config = Object.assign({}, defaultConfig, config);
        this.audioContext = audioContext;
        this.audioInput = null;
        this.realAudioInput = null;
        this.inputPoint = null;
        this.audioRecorder = null;
        this.rafID = null;
        this.analyserContext = null;
        this.recIndex = 0;
        this.stream = null;
        this.updateAnalysers = this.updateAnalysers.bind(this);
      }
      _createClass(Recorder2, [{
        key: "init",
        value: function init(stream) {
          var _this = this;
          return new Promise(function(resolve) {
            _this.inputPoint = _this.audioContext.createGain();
            _this.stream = stream;
            _this.realAudioInput = _this.audioContext.createMediaStreamSource(stream);
            _this.audioInput = _this.realAudioInput;
            _this.audioInput.connect(_this.inputPoint);
            _this.analyserNode = _this.audioContext.createAnalyser();
            _this.analyserNode.fftSize = 2048;
            _this.inputPoint.connect(_this.analyserNode);
            _this.audioRecorder = new _microphone2.default(_this.inputPoint);
            var zeroGain = _this.audioContext.createGain();
            zeroGain.gain.value = 0;
            _this.inputPoint.connect(zeroGain);
            zeroGain.connect(_this.audioContext.destination);
            _this.updateAnalysers();
            resolve();
          });
        }
      }, {
        key: "start",
        value: function start() {
          var _this2 = this;
          return new Promise(function(resolve, reject) {
            if (!_this2.audioRecorder) {
              reject("Not currently recording");
              return;
            }
            _this2.audioRecorder.clear();
            _this2.audioRecorder.record();
            resolve(_this2.stream);
          });
        }
      }, {
        key: "stop",
        value: function stop() {
          var _this3 = this;
          return new Promise(function(resolve) {
            _this3.audioRecorder.stop();
            _this3.audioRecorder.getBuffer(function(buffer) {
              _this3.audioRecorder.exportWAV(function(blob) {
                return resolve({ buffer, blob });
              });
            });
          });
        }
      }, {
        key: "updateAnalysers",
        value: function updateAnalysers() {
          if (this.config.onAnalysed) {
            requestAnimationFrame(this.updateAnalysers);
            var freqByteData = new Uint8Array(this.analyserNode.frequencyBinCount);
            this.analyserNode.getByteFrequencyData(freqByteData);
            var data = new Array(255);
            var lastNonZero = 0;
            var datum = void 0;
            for (var idx = 0; idx < 255; idx += 1) {
              datum = Math.floor(freqByteData[idx]) - Math.floor(freqByteData[idx]) % 5;
              if (datum !== 0) {
                lastNonZero = idx;
              }
              data[idx] = datum;
            }
            this.config.onAnalysed({ data, lineTo: lastNonZero });
          }
        }
      }, {
        key: "setOnAnalysed",
        value: function setOnAnalysed(handler) {
          this.config.onAnalysed = handler;
        }
      }]);
      return Recorder2;
    }();
    Recorder.download = function download(blob) {
      var filename = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "audio";
      _microphone2.default.forceDownload(blob, filename + ".wav");
    };
    exports.default = Recorder;
  }
});

// ../../../../../node_modules/recorder-js/index.js
var require_recorder_js = __commonJS({
  "../../../../../node_modules/recorder-js/index.js"(exports, module) {
    module.exports = require_lib();
  }
});
export default require_recorder_js();
//# sourceMappingURL=recorder-js.js.map
